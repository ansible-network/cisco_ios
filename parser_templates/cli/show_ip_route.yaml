---
- name: show_ip_route_vrf_all
  parser_metadata:
    version: 1.0
    command: "show ip route"
    network_os: ios

# Caveat: This parser only returns the first next hop, for prefixes with multiple possible destinations.

- name: match routing table values
  register: route_table
  pattern_group:

    - name: match route section
      pattern_match:
        regex: "Gateway of last resort"
        content: "{{ item }}"
        match_all: True
        match_greedy: True
      register: route_section

    - name: match prefixes
      pattern_match:
        regex: "^(?P<prot>L|C|S|R|M|B|D|EX|O|IA|N1|N2|E1|E2|i|su|L1|L2|ia|U|o|P|H|l|a)(?P<prot_args>\\s|\\*|\\+\\|\\%)\\s+(?P<prefix>\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3})(?P<mask>|\\/\\d{,2})(?:|\\s+\\[(?P<metric>\\d+/\\d+)\\]) (?P<source>is directly connected, (?P<next_hop_int>\\S+$)|is a summary, \\S+, (?P<next_hop_int_sum>\\S+$)|via (?P<next_hop_nbr>\\S+)(?:, |$))"
        content: "{{ route_section }}"
        match_all: true
      register: routes

- name: template vpn-instances
  register: DEFAULT
  extend: cisco_ios.network_instance.DEFAULT.vrf
  export: True
  export_as: dict
  json_template:
    template:
      - key: routing_table
        repeat_for: "{{ route_table.routes }}"
        repeat_var: nested_item
        object: "{{
          {
            nested_item.prefix+nested_item.mask:
            {
              'subnet': nested_item.prefix,
              'mask': nested_item.mask,
              'protocol': nested_item.prot | expand_routing_protocol_name,
              'dist_metric': nested_item.metric,
              'next_hop': ([nested_item.next_hop_nbr]+[nested_item.next_hop_int, nested_item.next_hop_int_sum]) | reject('equalto', '') | list
            }
          }
        }}"
